package com.exactlylabs.endlessapsscanner.service

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION
import android.net.wifi.WifiManager
import android.net.wifi.WifiManager.WifiLock
import android.os.Build
import android.os.Handler
import android.os.IBinder
import android.os.Looper
import android.os.PowerManager
import com.exactlylabs.endlessapsscanner.utils.Tags

// This class is just a plain foreground service that runs indefinitely
// It will execute a periodic task using the frequency provided
// In order to set a custom task to be executed, you need to extend this class and override the setHeadlessTask method
open class EndlessService : Service() {
    private lateinit var powerManager: PowerManager
    private lateinit var wifiManager: WifiManager
    internal lateinit var notificationManager: NotificationManager

    private var startId: Int? = null
    internal var frequency: Long = 1000

    private var wakeLock: PowerManager.WakeLock? = null
    private var wifiLock: WifiLock? = null

    internal var handler: Handler? = null

    internal open var ACTION_ALARM = "com.exactlylabs.endless_service.ACTION_ALARM"
    internal open var setAlarmIntentAction = "setAlarmIntentAction"

    internal open var receiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {

            // send timestamp through the module
            val data = "Periodic task data"
            setHeadlessTask("data", data)

            handler?.postDelayed({
                Intent(setAlarmIntentAction).also { intent ->
                    intent.action = ACTION_ALARM
                    intent.`package` = packageName
                    sendBroadcast(intent)
                }
            }, frequency)
        }
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        super.onStartCommand(intent, flags, startId)
//        setReactInBackground()
        /*
        This id is generated by the system and is unique for each service instance.
        This id is generated when the service is started with startService or startForegroundService.
        */
        this.startId = startId

        // create notification for the service
        val notification = createNotification()
        startForeground(500, notification, FOREGROUND_SERVICE_TYPE_LOCATION)

        // create handler for the periodic task
        // Run this handler on a separate thread to avoid blocking the main thread

        // register the receiver for the periodic task
        val receiverFlags = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            RECEIVER_NOT_EXPORTED
        } else {
            0
        }

        registerReceiver(receiver, IntentFilter().apply {
            addAction(ACTION_ALARM)
        }, receiverFlags)

        handler = Handler(Looper.getMainLooper())
        handler?.postDelayed({
            Intent(setAlarmIntentAction).also { intent ->
                intent.action = ACTION_ALARM
                intent.`package` = packageName
                sendBroadcast(intent)
            }
        }, frequency)

        setHeadlessTask("event", "onStart")

        return START_STICKY
    }

    override fun onCreate() {
        // This is called when calling Context.startService or Context.startForegroundService
        // This is called before onStartCommand

        /*
        Initialize the PowerManager and WifiManager.
        */
        startId = null
        powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
        wifiManager = getSystemService(Context.WIFI_SERVICE) as WifiManager
        notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager


        /*
        Remove any existing WakeLock and WifiLock before acquiring new ones.
        This is to ensure that we don't have multiple locks.
        */
        releaseLocks()
        acquireLocks()
    }


    override fun onDestroy() {
        setHeadlessTask("event", "onStop")
        // This is called when calling Context.stopService or Context.stopService

        /*
        Stop the specific service instance if it is running.
        */
        if (startId != null) {
            stopSelf(startId!!)
            startId = null
        }

        /*
        Release the WakeLock and WifiLock before stopping the service.
        */
        releaseLocks()

        handler?.removeCallbacksAndMessages(null)
        unregisterReceiver(receiver)
    }

    override fun onBind(p0: Intent?): IBinder? {
        println("onBind ${p0.toString()}")
        return null
    }

    /*
    - WakeLock: to keep the CPU awake
    - AlarmManager: to execute the task periodically

    #Description:
    The periodicity of the task will be achieved by the AlarmManager API.
    The AlarmManager acquires its own WakeLock to ensure that the CPU is awake to execute the task.
    BUT it will release the WakeLock as soon as the task is done.
    SO we need a WakeLock to ensure that the CPU is awake to keep the service running.

    - WifiLock: to keep the Wi-Fi radio awake

    #Description:
    Normally the Wi-Fi radio may turn off when the user has not used the device in a while.
    Acquiring a WifiLock will keep the radio on until the lock is released.
    */

    private fun acquireLocks() {
        wakeLock = powerManager.run {
            newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, Tags.kWakeLockTag).apply {
                acquire()
            }
        }

        wifiLock = wifiManager.run {
            createWifiLock(WifiManager.WIFI_MODE_FULL_LOW_LATENCY, Tags.kWifiLockTag).apply {
                acquire()
            }
        }
    }

    private fun releaseLocks() {
        wakeLock?.let {
            try {
                if (it.isHeld) {
                    it.release()
                }
            } finally {
                wakeLock = null
            }
        }

        wifiLock?.let {
            try {
                if (it.isHeld) {
                    it.release()
                }
            } finally {
                wifiLock = null
            }
        }
    }

    open fun createNotification(): Notification {
        val channelId = "EAS::notifications"
        val channelName = "EndlessApsScanner"
        val channelPriority = NotificationManager.IMPORTANCE_HIGH
        val channelDescription = "Notification channel for Endless Service"
        val notificationTitle = "Endless Service"
        val notificationText = "override createNotification() in your service to show a custom notification"
        val notificationVisibility = Notification.VISIBILITY_PUBLIC

        val notificationChannel = NotificationChannel(channelId, channelName, channelPriority)
        notificationChannel.description = channelDescription
        notificationChannel.setSound(null, null)
        notificationChannel.setShowBadge(true)
        notificationManager.createNotificationChannel(notificationChannel)

        val notificationBuilder = Notification.Builder(applicationContext, channelId)
        notificationBuilder.setOngoing(true)
        notificationBuilder.setShowWhen(false)
        notificationBuilder.setContentText(notificationTitle)
        notificationBuilder.setContentText(notificationText)
        notificationBuilder.setVisibility(notificationVisibility)
        notificationBuilder.setContentIntent(getPendingIntent())
        notificationBuilder.setSmallIcon(android.R.drawable.ic_dialog_info)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            notificationBuilder.setForegroundServiceBehavior(Notification.FOREGROUND_SERVICE_IMMEDIATE)
        }

        return notificationBuilder.build()
    }

    internal fun getPendingIntent(): PendingIntent {
        val launchIntent = packageManager.getLaunchIntentForPackage(applicationContext.packageName)
        return PendingIntent.getActivity(this, 20000, launchIntent, PendingIntent.FLAG_IMMUTABLE)
    }

    // Here you can send data to the Headless JS task
    // This should be overridden in the subclass
    open fun setHeadlessTask(name: String, value: String) {}
}